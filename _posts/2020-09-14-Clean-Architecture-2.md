---
layout: post
title: "Clean Architecture 2"
categories: develop
---

## SOLID

- SRP(Single Responsibility Principle)
- OCP(Open-Closed Principle)
- LSP(Liskov Substitution Principle)
- ISP(Interface Segregation Principle)
- DIP(Dependency Inversion Principle)

### SRP
> 하나의 `모듈`은 하나의, 오직 하나의 `액터`에 대해서만 책임져야 한다.

- 액터가 다르면 기능을 분리 해야 한다.
- 기능 중복제거를 하거나, 병합하는 과정에서 원하지 않는 수정이 발생 할 수 있다.
- SRP는 메서드와 클래스의 수준이다. (저수준의 메서드를 말하는게 아님)

### OCP
> 소프트웨어 `개체의 행위는 확장` 할 수 있어야 하지만, 이때 `산출물을 변경해서는 안 된다.`

- SRP로 기능 분리, 분리한 기능을 컴포넌트의 계층구조로 조직화 한다.
- 고수준과 저수준들의 레벨을 정리하고 저수준으로 부터 고수준을 보호한다.
- 확장(변경)하기 쉽고, 변경사항의 범위를 최소화 한다.

### LSP
> 하위 타입은 모두 싱위(Interface) 타입을 치환할 수있음.

- 상속 가이드 -> 아키텍쳐 관점으로 확장
- LSP가 위배가 되면, 의도치 않은 예외가 발생한다

### ISP
> 불필요한 모듈에 의존하지 않는다.

- 필요 이상으로 많은 걸 포함하는 모듈에 의존하면, 재배포 및 재컴파일을 강제 한다.

### DIP
> 의존성이 추상에 의존하며 구체에는 의존 하지 않는 시스템.

- 현실적으로 불가능 BUT 변동성이 큰 구체에 대해 의존성을 가지지 않도록 한다.
- 인터페이스 보다 구체가 변경 가능성이 높다. 따라서 인터페이스를 변경하지 않고 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력 해야 한다.
- 변동성이 큰 구체 클래스 사용 제한 (참조 X, 상송 X, 메소드 오버라이드 X)
- `Factory`를 통해 사용할 기능의 구현체를 생성하도록 한다. (의존성 분리)
